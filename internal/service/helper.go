package service

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/catalystgo/logger/log"
	"golang.org/x/mod/modfile"
)

// fileExists checks if a file exists.
func fileExists(filePath string) bool {
	_, err := os.Stat(filePath)
	return !os.IsNotExist(err)
}

// getCurrentModule returns the current module name from go.mod file.
func getCurrentModule() (string, error) {
	goModBytes, err := os.ReadFile("go.mod")
	if err != nil {
		return "", fmt.Errorf("failed to read go.mod file: %v", err)
	}

	modName := modfile.ModulePath(goModBytes)
	if modName == "" {
		return "", fmt.Errorf("failed to get module name from go.mod file")
	}

	return modName, nil
}

// getGrpcGoFiles returns a list of files that are generated by protoc-gen-go-grpc.
func getGrpcGoFiles(input string) ([]string, error) {
	var files []string

	log.Debugf("walking directory: %s", input)
	err := filepath.WalkDir(input, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}

		// If the path is a directory, recursively walk the directory
		if d.IsDir() {
			return nil
		}

		// Check if the file is a generated file from protoc-gen-go-grpc
		// and add it to the list of files
		if strings.HasSuffix(path, gprcFileSuffix) {
			log.Debugf("found grpc go file: %s", path)
			files = append(files, path)
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("failed to walk directory: %v", err)
	}

	return files, nil
}

// parseGoFiles parses a list of Go files and returns the AST.
func parseGoFiles(files []string) (map[string]*ast.File, error) {
	parsedFiles := make(map[string]*ast.File, len(files))
	for _, file := range files {
		node, err := parseGoFile(file)
		if err != nil {
			return nil, err
		}
		parsedFiles[file] = node
	}
	return parsedFiles, nil
}

// parseGoFile parses a Go file and returns the AST.
func parseGoFile(file string) (*ast.File, error) {
	fset := token.NewFileSet()

	node, err := parser.ParseFile(fset, file, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("error parsing file (%s): %v", file, err)
	}

	return node, nil
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, c := range s {
		if i > 0 && unicode.IsUpper(c) {
			result.WriteByte('_')
		}
		result.WriteRune(c)
	}
	return strings.ToLower(result.String())
}

// getStructName returns the name of a struct that has a specific prefix and suffix.
// Example: If we call getStructName(node, "Unimplemented", "Service")
// and the struct name is "UnimplementedSERVICENAMEService", the function will return "UnimplementedSERVICENAMEService".
func getStructName(node *ast.File, prefix string, suffix string) string {
	for _, decl := range node.Decls {
		if genDecl, ok := decl.(*ast.GenDecl); ok {
			for _, spec := range genDecl.Specs {
				if typeSpec, ok := spec.(*ast.TypeSpec); ok {
					if _, ok := typeSpec.Type.(*ast.StructType); ok {
						name := typeSpec.Name.Name
						if strings.HasPrefix(name, prefix) && strings.HasSuffix(name, suffix) {
							log.Debugf("found struct %q", name)
							return name
						}
					}
				}
			}
		}
	}
	return ""
}

// getStructMethods returns a list of methods of a struct.
func getStructMethods(node *ast.File, structName string) []*ast.FuncDecl {
	methods := make([]*ast.FuncDecl, 0)
	for _, decl := range node.Decls {
		if funcDecl, ok := decl.(*ast.FuncDecl); ok {
			// skip if the function is not a method
			if funcDecl.Recv == nil {
				continue
			}

			for _, field := range funcDecl.Recv.List {
				// get the recvName of the method
				var recvName string
				switch se := field.Type.(type) {
				case *ast.StarExpr: // pointer
					if ident, ok := se.X.(*ast.Ident); ok {
						recvName = ident.Name
					}
				case *ast.Ident: // non-pointer
					recvName = se.Name
				}

				// if recvName is equal to structName, add the method to the list
				if recvName == structName {
					log.Debugf("found method %q in struct %q", funcDecl.Name.Name, structName)
					methods = append(methods, funcDecl)
				}
			}
		}
	}
	return methods
}
